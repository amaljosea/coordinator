{"version":3,"sources":["components/trackingComponent.js","components/threeJsComponent.js","constants/cordinatesLimits.js","components/Convert2dTo3d.js","index.js"],"names":["TrackingComponent","props","useEffect","video","document","getElementById","canvas","context","getContext","updateNote","model","runDetection","height","window","innerHeight","width","innerWidth","detect","then","predictions","length","bbox","x","y","radius","onCoordiantesChange","renderPredictions","requestAnimationFrame","handTrack","flipHorizontal","maxNumBoxes","iouThreshold","scoreThreshold","lmodel","innerText","status","console","log","id","autoPlay","style","display","THREE","require","ThreeJsComponent","useState","ourSourceSphere","setOurSourceSphere","scene","Scene","camera","PerspectiveCamera","renderer","WebGLRenderer","setSize","appendChild","domElement","geometry1","BoxGeometry","material1","MeshBasicMaterial","wireframe","transparent","opacity","color","geometry","Mesh","SphereGeometry","material","sourceGeometry","sourceMaterial","sourceSphere","add","position","set","z","animate","render","coordiantes","inputCoordiantesLimits","max","min","undefined","outputCoordiantesLimits","Convert2dTo3d","videoStarted","setVideoStarted","setCoordiantes","onClick","newCoordinates","inputScaleRadius","outputScaleRadius","convertCoordinatesForThreeJs","ReactDOM"],"mappings":"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","file":"static/js/main.1e9adc18.chunk.js","sourcesContent":["import React, { useEffect } from \"react\";\nimport * as handTrack from \"handtrackjs\";\n\n/*\n * Convert2dTo3d is used to track coordinates of hand\n */\nfunction TrackingComponent(props) {\n  useEffect(() => {\n    const video = document.getElementById(\"myvideo\");\n    const canvas = document.getElementById(\"canvas\");\n    const context = canvas.getContext(\"2d\");\n    let updateNote = document.getElementById(\"updatenote\");\n    let model = null;\n\n    const modelParams = {\n      flipHorizontal: true, // flip e.g for video\n      maxNumBoxes: 1, // maximum number of boxes to detect\n      iouThreshold: 0.5, // ioU threshold for non-max suppression\n      scoreThreshold: 0.6 // confidence threshold for predictions.\n    };\n\n    function runDetection() {\n      video.height = window.innerHeight;\n      video.width = window.innerWidth;\n      model.detect(video).then(predictions => {\n        if (predictions.length) {\n          const bbox = predictions[0].bbox;\n          const width = bbox[2];\n          const height = bbox[3];\n          const x = width / 2 + bbox[0];\n          const y = height / 2 + bbox[1];\n          const radius = (width + height) / 4;\n          props.onCoordiantesChange({ radius: radius, x:x, y:y });\n        }\n        model.renderPredictions(predictions, canvas, context, video);\n        requestAnimationFrame(runDetection);\n      });\n    }\n\n    function startVideo() {\n      handTrack.startVideo(video).then(function(status) {\n        console.log(\"video started\", status);\n        if (status) {\n          updateNote.innerText = \"Video started. Now tracking\";\n          runDetection();\n        } else {\n          updateNote.innerText = \"Please enable video\";\n        }\n      });\n    }\n\n    handTrack.load(modelParams).then(lmodel => {\n      // detect objects in the image.\n      model = lmodel;\n      updateNote.innerText = \"Loaded Model!\";\n    });\n\n    updateNote.innerText = \"Starting video\";\n    startVideo();\n\n    return () => {\n      updateNote.innerText = \"Stopping video\";\n      handTrack.stopVideo(video);\n    };\n  }, []);\n\n  return (\n    <div>\n      <h1>TrackingComponent</h1>\n      <div id=\"updatenote\"> loading model ..</div>\n      <video\n        autoPlay=\"autoplay\"\n        id=\"myvideo\"\n        style={{ display: \"none\", width: \"100%\", height: \"100%\" }}\n      ></video>\n      <canvas id=\"canvas\"></canvas>\n    </div>\n  );\n}\n\nexport default TrackingComponent;\n","import React, {useEffect,useState} from 'react';\nvar THREE = require('three');\n\n/*\n * Convert2dTo3d is used to display in 3d\n */\nfunction ThreeJsComponent(props) {\nconst [ourSourceSphere, setOurSourceSphere]=useState(null)\nuseEffect(()=>{\n    var scene = new THREE.Scene();\n    var camera = new THREE.PerspectiveCamera( 40, window.innerWidth/window.innerHeight, 0.1, 1000 );\n\n    var renderer = new THREE.WebGLRenderer();\n    renderer.setSize( window.innerWidth, window.innerHeight );\n    document.getElementById(\"threejsarea\").appendChild( renderer.domElement );\n\n   // var texture = new THREE.TextureLoader().load( 'texture/square.png' );\n\n    var geometry1 = new THREE.BoxGeometry( 5, 5, 5 );\n    var material1 = new THREE.MeshBasicMaterial( { wireframe: true , transparent: true, opacity: .5, color: 0xffff00} );\n    var cube1 = new THREE.Mesh( geometry1, material1 );\n    \n    //scene.add( cube1 );\n\n\n    var geometry = new THREE.SphereGeometry( 1.5, 32, 32 );\n    var material = new THREE.MeshBasicMaterial({ wireframe: true , transparent: false, opacity: 1, color: 0xffffff} );\n    var sphere = new THREE.Mesh( geometry, material );\n    //scene.add( sphere );\n\n    var sourceGeometry = new THREE.SphereGeometry( .5, 32, 32 );\n    var sourceMaterial = new THREE.MeshBasicMaterial({  wireframe: true, transparent: false, opacity: 100, color: 0xffffff});\n    var sourceSphere = new THREE.Mesh( sourceGeometry, sourceMaterial );\n    scene.add( sourceSphere );\n    sourceSphere.position.set(5, 0, 0);\n    setOurSourceSphere(sourceSphere)\n    console.log(\"sourceSphere.position\",sourceSphere.position)\n    camera.position.z = 20;\n    var animate = function () {\n        requestAnimationFrame( animate );\n\n        // cube1.rotation.x += .01;\n        // cube1.rotation.y += .01;\n        \n        // sphere.rotation.x += .01;\n        // sphere.rotation.y += .01;\n\n        renderer.render( scene, camera );\n    };\n\n    animate();\n},[])\n\nuseEffect(()=>{\n  if(ourSourceSphere){\n    ourSourceSphere.position.set(props.coordiantes.x,props.coordiantes.y,props.coordiantes.z)\n  }\n}, [props.coordiantes.z,props.coordiantes.x,props.coordiantes.y])\n\n\n  return (\n    <div>\n        <h1>ThreeJsComponent</h1>\n        <div id=\"threejsarea\"></div>\n    </div>\n  );\n}\n\nexport default ThreeJsComponent;\n","export const inputCoordiantesLimits = {\n    radius: {\n      max:368,\n      min:41\n    },\n    x:{\n      max:undefined,\n      min:undefined\n    },\n    z:{\n      max:undefined,\n      min:undefined\n    }\n  }\n  \nexport const outputCoordiantesLimits = {\n    z: {\n      max:+18,\n      min:-2\n    },\n    x: {\n      max:undefined,\n      min:undefined\n    },\n    y: {\n      max:undefined,\n      min:undefined\n    }\n  }","import React, { useState } from \"react\";\nimport TrackingComponent from \"./trackingComponent\";\nimport ThreeJsComponent from \"./threeJsComponent\";\nimport {\n  inputCoordiantesLimits,\n  outputCoordiantesLimits\n} from \"../constants/cordinatesLimits\";\n\n/*\n * Convert2dTo3d is used to convert and display coordinates in 2d to 3d\n */\nfunction Convert2dTo3d() {\n  const [videoStarted, setVideoStarted] = useState(false);\n  const [coordiantes, setCoordiantes] = useState({\n    radius: 0,\n    x: 0,\n    y:0\n  });\n\n  const onCoordiantesChange= (newCoordinates)=>{\n    setCoordiantes(newCoordinates)\n  }\n\n  const convertCoordinatesForThreeJs = () => {\n    const inputScaleRadius =\n      inputCoordiantesLimits.radius.max - inputCoordiantesLimits.radius.min;\n    const outputScaleRadius =\n      outputCoordiantesLimits.z.max - outputCoordiantesLimits.z.min;\n    const ratio = coordiantes.radius / inputScaleRadius;\n    const outputValueInScaleRadius = ratio * outputScaleRadius;\n    const outputValueRadius = outputValueInScaleRadius + outputCoordiantesLimits.z.min; //making integer\n    return { z: outputValueRadius, x:0, y:0 }; //now z is only calculated, start working from here\n  };\n\n  return (\n    <div>\n      <button onClick={() => setVideoStarted(!videoStarted)}>\n        {videoStarted ? \"STOP\" : \"START\"}\n      </button>\n      {videoStarted && <TrackingComponent onCoordiantesChange={onCoordiantesChange} />}\n      {videoStarted && <ThreeJsComponent coordiantes={convertCoordinatesForThreeJs()} />}\n    </div>\n  );\n}\n\nexport default Convert2dTo3d;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Convert2dTo3d from './components/Convert2dTo3d.js';\n\nReactDOM.render(<Convert2dTo3d />, document.getElementById('root'));"],"sourceRoot":""}